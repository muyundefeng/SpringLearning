package com.designmodel.state;

/**状态模式用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题。当系统中某个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可以使用状态模式
 * 。状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化，
 * 对于客户端而言，无须关心对象状态的转换以及对象所处的当前状态，无论对于何种状态的对象，客户端都可以一致处理。
 *
 *
 * ● Context（环境类）：环境类又称为上下文类，它是拥有多种状态的对象。由于环境类的状态存在多样性且在不同状态下对象的行为有所不同，因此将状态独立出去形成单独的状态类。在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象。
 ● State（抽象状态类）：它用于定义一个接口以封装与环境类的一个特定状态相关的行为，在抽象状态类中声明了各种不同状态对应的方法，而在其子类中实现类这些方法，由于不同状态下对象的行为可能不同，因此在不同子类中方法的实现可能存在不同，相同的方法可以写在抽象状态类中。
 ● ConcreteState（具体状态类）：它是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。
 * 状态模式，模拟银行账户的三种状态：正常状态，超支状态以及受限状态
 * 定义抽象状态类：三种状态的公共主要的操作有：存款，取款，计算利息，当前余额等操作
 *
 *
 * 在状态模式中，我们将对象在不同状态下的行为封装到不同的状态类中，为了让系统具有更好的灵活性和可扩展性，
 * 同时对各状态下的共有行为进行封装，我们需要对状态进行抽象，引入了抽象状态类角色，
 *
 * 适用场景
 在以下情况下可以考虑使用状态模式：
 (1) 对象的行为依赖于它的状态（如某些属性值），状态的改变将导致行为的变化。
 (2) 在代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，
 不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强。
 *
 * Created by lisheng on 17-3-27.
 */
public abstract class State {
    public Account account;//关联一个用户的账户

    public abstract void disposit(int money);

    public abstract void withdraw(int money);

    public abstract void computeInterest();

    public abstract void stateCheck();//进行状态之间的转换
}
