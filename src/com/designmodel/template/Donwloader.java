package com.designmodel.template;

/**
 * 某个方法的实现需要多个步骤（类似“请客”），其中有些步骤是固定的（类似“点单”和“买单”），
 * 而有些步骤并不固定，存在可变性（类似“吃东西”）。为了提高代码的复用性和系统的灵活性，
 * 可以使用一种称之为模板方法模式的设计模式来对这类情况进行设计，在模板方法模式中，
 * 将实现功能的每一个步骤所对应的方法称为基本方法（例如“点单”、“吃东西”和“买单”），
 * 而调用这些基本方法同时定义基本方法的执行次序的方法称为模板方法（例如“请客”）。
 * <p>
 * 模板方法模式是结构最简单的行为型设计模式，在其结构中只存在父类与子类之间的继承关系。
 * 通过使用模板方法模式，可以将一些复杂流程的实现步骤封装在一系列基本方法中，
 * 在抽象父类中提供一个称之为模板方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，
 * 从而使得相同的算法框架可以有不同的执行结果。
 * <p>
 * (1) AbstractClass（抽象类）：在抽象类中定义了一系列基本操作(PrimitiveOperations)，这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时，在抽象类中实现了一个模板方法(Template Method)，用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。
 * (2) ConcreteClass（具体子类）：它是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作。
 * <p>
 * <p>
 * <p>
 * 使用场景：
 * (1) 对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。即：一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。
 * (2) 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。
 * (3) 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。
 * <p>
 * 模板方法模式
 * 使用下载器下载文件
 * 无论采用什么养的下载器，一般步骤都是：发起请求-->处理请求-->返回影响实体-->通过下载器保存文件
 * 其中下载器可以使用chrome浏览器，迅雷，或者自定义下载器下载
 * Created by lisheng on 17-3-27.
 */
public abstract class Donwloader {
    //定义的方法执行的顺序,模板方法
    public void templateMethod() {
        startRequest();
        processRequest();
        returnEntity();
        saveToFile();
    }

    //发起请求
    public void startRequest() {
        System.out.println("通用发请求方法");
    }

    //处理请求
    public void processRequest() {
        System.out.println("服务器处理请求");
    }

    //返回响应实体
    public void returnEntity() {
        System.out.println("服务器返回响应实体");
    }

    //子类覆盖该方法实现不同文件下载方式
    public abstract void saveToFile();//保存文件
}
